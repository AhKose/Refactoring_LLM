### MANIFESTO - PERSISTENCE SERVICE REFACTORING ###
- Role: Senior Architect
- Target Module: tools.descartes.teastore.persistence
- Architecture: JAX-RS (Jersey)
- Guardrails: 
  1. API Stability: Do NOT change @Path or public method signatures.
  2. Structural Integrity: Do NOT modify interfaces/entities modülü.
  3. No New Dependencies: Stay within the current pom.xml limits.
- Principles: Focus on High Cohesion, Low Coupling, and Single Responsibility.
- Output: Return only changed files in ### FILE: <path> ... ### END FILE format.

### FILE: repository\DataGenerator.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;

import jakarta.persistence.EntityManager;
import jakarta.ws.rs.client.Entity;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import org.eclipse.persistence.sessions.server.ServerSession;
import org.eclipse.persistence.tools.schemaframework.SchemaManager;
import org.mindrot.jbcrypt.BCrypt;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.domain.PersistenceCategory;
import tools.descartes.teastore.persistence.domain.PersistenceOrder;
import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.util.RESTClient;
import tools.descartes.teastore.entities.Category;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Class for generating data in the database.
 *
 * @author Joakim von Kistowski
 *
 */
public final class DataGenerator {

	/**
	 * Status code for maintenance mode.
	 */
	public static final int MAINTENANCE_STATUS_CODE = 503;

	/**
	 * Default category count for small database.
	 */
	public static final int SMALL_DB_CATEGORIES = 5;
	/**
	 * Default product count per category for small database.
	 */
	public static final int SMALL_DB_PRODUCTS_PER_CATEGORY = 100;
	/**
	 * Default user count for small database.
	 */
	public static final int SMALL_DB_USERS = 100;
	/**
	 * Default max order per user for small database.
	 */
	public static final int SMALL_DB_MAX_ORDERS_PER_USER = 5;

	/**
	 * Default category count for tiny database.
	 */
	public static final int TINY_DB_CATEGORIES = 2;
	/**
	 * Default product count per category for tiny database.
	 */
	public static final int TINY_DB_PRODUCTS_PER_CATEGORY = 20;
	/**
	 * Default user count for tiny database.
	 */
	public static final int TINY_DB_USERS = 5;
	/**
	 * Default max order per user for tiny database.
	 */
	public static final int TINY_DB_MAX_ORDERS_PER_USER = 2;

	private Random random = new Random(5);

	private static final String PASSWORD = "password";
	private static final String[] CATEGORYNAMES = { "Black Tea", "Green Tea", "Herbal Tea", "Rooibos", "White Tea",
			"Tea Cups", "Tea Pots", "Filters", "Infusers" };
	private static final String[] CATEGORYDESCRIPTIONS = { "Pure black tea and blends", "From China and Japan",
			"Helps when you feel sick", "In many variations", "If green tea doesn't agree with you",
			"Cups and glasses", "Classy and useful", "For extremely fine grained tea",
			"No metal for green tea" };

	private static final String[][] PRODUCTNAMES = {
			{ "Earl Grey (loose)", "Assam (loose)", "Darjeeling (loose)", "Frisian Black Tee (loose)",
				"Anatolian Assam (loose)", "Earl Grey (20 bags)", "Assam (20 bags)", "Darjeeling (20 bags)",
				"Ceylon (loose)", "Ceylon (20 bags)", "House blend (20 bags)", "Assam with Ginger (20 bags)"},
			{ "Sencha (loose)", "Sencha (15 bags)", "Sencha (25 bags)", "Earl Grey Green (loose)",
					"Earl Grey Green (15 bags)", "Earl Grey Green (25 bags)", "Matcha 30 g", "Matcha 50 g",
					"Matcha 100 g", "Gunpowder Tea (loose)", "Gunpowder Tea (15 bags)", "Gunpowder Tea (25 bags)" },
			{ "Camomile (loose)", "Camomile (15 bags)", "Peepermint (loose)", "Peppermint (15 bags)",
					"Peppermint (15 bags)", "Sweet Mint (loose)", "Sweet Mint (15 bags)", "Sweet Mint (25 bags)",
					"Lemongrass (loose)", "Lemongrass (20 bags)", "Chai Mate (15 bags)", "Chai Mate (25 bags)",
					"Stomach Soothing Tea (15 bags)", "Headache Soothing Tea (15 bags)" },
			{ "Rooibos Pure (loose)", "Rooibos Pure (20 bags)", "Rooibos Orange (loose)", "Rooibos Orange (20 bags)",
					"Rooibos Coconut (loose)", "Rooibos Coconut (20 bags)", "Rooibos Vanilla (loose)",
					"Rooibos Pure (20 bags)", "Rooibos Ginger (loose)", "Rooibos Pure (20 bags)",
					"Rooibos Grapefruit (loose)", "Rooibos Pure (20 bags)" },
			{ "White Tea (loose)", "White Tea (15 bags)", "White Tea (25 bags)", "White Chai (loose)",
					"White Chai (15 bags)", "White Chai (25 bags)", "Pai Mu Tan White (loose)",
					"Pai Mu Tan White (15 bags)", "Pai Mu Tan White (25 bags)", "White Apricot (loose)",
					"White Apricot (15 bags)", "White Apricot (25 bags)" },
			{ "Ceramic Cup White", "Ceramic Cup Blue", "Ceramic Cup Green", "Ceramic Cup Black",
					"Percelain Cup White", "Porcelain Cup with Flowers", "Poercelain Cup with Dog Picture",
					"Small Glass Cup", "Large Glass Cup", "Small Glass Cup with Glass Infuser",
					"Large Glass Cup with Glass Infuser", "Small Glass Cup with Plastic Infuser",
					"Large Glass Cup with Plastic Infuser" },
			{ "Porcelain Teapot White, 2 Cups", "Porcelain Teapot White, 5 Cups",
					"Porcelain Teapot with Flowers, 2 Cups", "Porcelain Teapot with Flowers, 5 Cups",
					"Persian Teapot, 3 Cups", "Large Teapot with Glass Infuser, 7 Cups",
					"Small Teapot with Glass Infuser, 3 Cups", "Medium Teapot with Glass Infuser, 5 Cups",
					"Large Glass Teapot with Steel Infuser, 7 Cups", "Small Glass Teapot with Steel Infuser, 3 Cups",
					"Medium Glass Teapot with Steel Infuser, 5 Cups", "Glass Teapot Warmer" },
			{ "Filters with Drawstring, 100 pcs.", "Filters with Drawstring, 250 pcs.",
					"Filters with Drawstring, 500 pcs.", "Tea Sack, 50 pcs.", "Tea Sack, 125 pcs.",
					"Tea Sack, 500 pcs.", "Reusible Cotton Tea Sack, 10 pcs.", "Reusible Cotton Tea Sack, 35 pcs.",
					"Reusable Cotton Tea Sack, 50 pcs.", "Pyramid-shaped Tea Filter, 10 pcs.",
					"Pyramid-shaped Tea Filter, 25 pcs.", "Mr. Tea Filter, 10 pcs." },
			{ "Medium Mesh Ball with Chain", "Medium Snap Mesh Ball", "Large Ball with Chain",
						"Small Mesh Ball with Chain", "Small Snap Mesh Ball", "Large Snap Mesh Ball",
						"Medium Silicone Ball Infuser", "Small Silicone Ball Infuser",
					"Large Silicone Ball Infuser", "Small Mesh Ball with Panda Look", "Heart-shaped Infuser" } };

	private static final String[] FIRSTNAMES = {"James", "John", "Robert", "Michael", "William", "David",
			"Richard", "Charles", "Jospeph", "Thomas", "Christopher", "Daniel", "Paul", "Mark", "Donald",
			"George", "Kenneth", "Steven", "Edward", "Brian", "Ronald", "Anthony", "Kevin", "Jason",
			"Matthew", "Gary", "Timothy", "Jose", "Larry", "Jeffrey", "Frank", "Scott", "Eric", "Stephen",
			"Andrew", "Raymond", "Gregory", "Joshua", "Jerry", "Dennis", "Walter", "Patrick", "Peter",
			"Mary", "Patricia", "Barbara", "Elizabeth", "Jennifer", "Maria", "Susan", "Margaret", "Dorothy",
			"Lisa", "Nancy", "Karen", "Betty", "Helen", "Sandra", "Donna", "Carol", "Ruth", "Sharon",
			"Michelle", "Laura", "Sarah", "Kimberly", "Deborah", "Jessica", "Shirley", "Cynthia"};
	private static final String[] LASTNAMES = {"Smith", "Johnson", "Williams", "Jones", "Brown", "Davis",
			"Miller", "Wilson", "Moorse", "Taylor", "Anderson", "Thomas", "Jackson", "White", "Harris",
			"Martin", "Thompson", "Garcia", "Martinez", "Robinson", "Clark", "Rodriguez", "Lewis", "Lee",
			"Walker", "Hall", "Allen", "Young", "Hernandez", "King", "Wright", "Lopez", "Hill", "Scoot"};

	private static final int MAX_ITEMS_PER_ORDER = 10;
	private static final double PREFFERED_CATEGORY_CHANCE = 0.825;


	/**
	 * The data generator singleton.
	 */
	public static final DataGenerator GENERATOR = new DataGenerator();

	private boolean maintenanceMode = false;

	private DataGenerator() {

	}

	/**
	 * Checks if the database is empty.
	 *
	 * @return True if the database is empty.
	 */
	public boolean isDatabaseEmpty() {
		// every other entity requires a valid category or user
		return (CategoryRepository.REPOSITORY.getAllEntities(-1, 1).size() == 0
				&& UserRepository.REPOSITORY.getAllEntities(-1, 1).size() == 0);
	}

	/**
	 * Generates data for the database. Uses a fixed random seed.
	 *
	 * @param categories
	 *            Number of categories.
	 * @param productsPerCategory
	 *            Number of products per category.
	 * @param users
	 *            Number of users. Password is always "password".
	 * @param maxOrdersPerUser
	 *            Maximum order per user.
	 */
	public void generateDatabaseContent(int categories, int productsPerCategory,
			int users, int maxOrdersPerUser) {
		setGenerationFinishedFlag(false);
		CacheManager.MANAGER.clearAllCaches();
		random = new Random(5);
		generateCategories(categories);
		generateProducts(productsPerCategory);
		generateUsers(users);
		generateOrders(maxOrdersPerUser, productsPerCategory);
		setGenerationFinishedFlag(true);
		CacheManager.MANAGER.clearAllCaches();
	}

	private void generateCategories(int categories) {
		for (int i = 0; i < categories; i++) {
			Category category = new Category();
			if (i < CATEGORYDESCRIPTIONS.length) {
				category.setDescription(CATEGORYDESCRIPTIONS[i]);
			} else {
				int version = i / CATEGORYDESCRIPTIONS.length;
				category.setDescription(CATEGORYDESCRIPTIONS[i % CATEGORYDESCRIPTIONS.length] + ", v" + version);
			}
			if (i < CATEGORYNAMES.length) {
				category.setName(CATEGORYNAMES[i]);
			} else {
				int version = i / CATEGORYNAMES.length;
				category.setName(CATEGORYNAMES[i % CATEGORYNAMES.length] + ", v" + version);
			}
			CategoryRepository.REPOSITORY.createEntity(category);
		}
	}

	private void generateProducts(int productsPerCategory) {
		int categoryIndex = 0;
		for (PersistenceCategory category : CategoryRepository.REPOSITORY.getAllEntities()) {
			int productTypeIndex = categoryIndex % PRODUCTNAMES.length;
			for (int i = 0; i < productsPerCategory; i++) {
				int productIndex = i % PRODUCTNAMES[productTypeIndex].length;
				int version = i / PRODUCTNAMES[productTypeIndex].length;
				Product product = new Product();
				if (version == 0) {
					product.setName(PRODUCTNAMES[productTypeIndex][productIndex]);
				} else {
					product.setName(PRODUCTNAMES[productTypeIndex][productIndex] + ", v" + version);
				}
				product.setDescription(
						"Great " + category.getName() + ": " + PRODUCTNAMES[productTypeIndex][productIndex]);
				product.setListPriceInCents(95 + random.nextInt(12000));
				product.setCategoryId(category.getId());
				ProductRepository.REPOSITORY.createEntity(product);
			}
			categoryIndex++;
		}
	}

	private void generateUsers(int users) {
		IntStream.range(0, users).parallel().forEach(i -> {
			User user = new User();
			user.setUserName("user" + i);
			user.setEmail("user" + i + "@teastore.com");
			user.setRealName(FIRSTNAMES[random.nextInt(FIRSTNAMES.length)]
					+ " " + LASTNAMES[random.nextInt(LASTNAMES.length)]);
			user.setPassword(BCrypt.hashpw(PASSWORD, BCrypt.gensalt(6)));
			UserRepository.REPOSITORY.createEntity(user);
		});
	}

	private void generateOrders(int maxOrdersPerUser, int productsPerCategory) {
		UserRepository.REPOSITORY.getAllEntities().parallelStream().forEach(user -> {
			for (int i = 0; i < random.nextInt(maxOrdersPerUser + 1); i++) {
				Order order = new Order();
				order.setAddressName(user.getRealName());
				String eastWest = " East ";
				if (random.nextDouble() > 0.5) {
					eastWest = " West ";
				}
				String northSouth = " North";
				if (random.nextDouble() > 0.5) {
					northSouth = " South";
				}
				order.setAddress1(random.nextInt(9000) + eastWest + random.nextInt(9000) + northSouth);
				order.setAddress2("District " + random.nextInt(500) + ", Utopia, " + (10000 + random.nextInt(40000)));
				order.setCreditCardCompany("MasterCard");
				if (random.nextDouble() > 0.5) {
					order.setCreditCardCompany("Visa");
				}
				order.setCreditCardExpiryDate(LocalDate.ofYearDay(LocalDateTime.now().getYear()
						+ 1 + random.nextInt(10), 1 + random.nextInt(363)).format(DateTimeFormatter.ISO_LOCAL_DATE));
				order.setTime(LocalDateTime.of(LocalDateTime.now().getYear() - random.nextInt(10),
						1 + random.nextInt(10), 1 + random.nextInt(24), random.nextInt(23), random.nextInt(59))
						.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
				order.setUserId(user.getId());
				order.setCreditCardNumber(fourDigits() + " " + fourDigits() + " " + fourDigits() + " " + fourDigits());
				long orderId = OrderRepository.REPOSITORY.createEntity(order);
				PersistenceOrder createdOrder = OrderRepository.REPOSITORY.getEntity(orderId);
				long price = 0;
				List<PersistenceCategory> categories = CategoryRepository.REPOSITORY.getAllEntities();
				Category preferred = categories.get(random.nextInt(categories.size()));
				for (int j = 0; j < 1 + random.nextInt(MAX_ITEMS_PER_ORDER); j++) {
					OrderItem item = generateOrderItem(createdOrder, preferred, productsPerCategory);
					price += item.getQuantity() * item.getUnitPriceInCents();
					OrderItemRepository.REPOSITORY.createEntity(item);
				}
				createdOrder.setTotalPriceInCents(price);
				OrderRepository.REPOSITORY.updateEntity(orderId, createdOrder);
			}
		});
	}

	//Order and preferred category must have a valid id!
	private OrderItem generateOrderItem(Order order, Category preferred, int productsPerCategory) {
		OrderItem item = new OrderItem();
		item.setOrderId(order.getId());
		item.setQuantity(random.nextInt(7));
		Category itemCategory = preferred;
		if (random.nextDouble() > PREFFERED_CATEGORY_CHANCE) {
			List<PersistenceCategory> categories = CategoryRepository.REPOSITORY.getAllEntities();
			itemCategory = categories.get(random.nextInt(categories.size()));
		}
		Product product = ProductRepository.REPOSITORY.getAllEntities(
				itemCategory.getId(), random.nextInt(productsPerCategory), 1).get(0);
		item.setProductId(product.getId());
		item.setUnitPriceInCents(product.getListPriceInCents());
		return item;
	}

	private String fourDigits() {
		return String.valueOf(1000 + random.nextInt(8999));
	}

	/**
	 * Drops database and recreates all tables.<br/>
	 * Attention: Does not reset foreign persistence contexts.
	 * Best practice is to call CacheManager.MANAGER.resetAllEMFs() after dropping and then recreating the DB.
	 */
	public void dropAndCreateTables() {
		CacheManager.MANAGER.clearLocalCacheOnly();
		ServerSession session = CategoryRepository.REPOSITORY.getEM().unwrap(ServerSession.class);
		SchemaManager schemaManager = new SchemaManager(session);
		schemaManager.replaceDefaultTables(true, true);
		CacheManager.MANAGER.clearLocalCacheOnly();
		CacheManager.MANAGER.resetLocalEMF();
		setGenerationFinishedFlag(false);
		CacheManager.MANAGER.clearAllCaches();
	}

	private void setGenerationFinishedFlag(boolean flag) {
		EntityManager em = CategoryRepository.REPOSITORY.getEM();
		try {
			em.getTransaction().begin();
			List<DatabaseManagementEntity> entities =
					em.createQuery("SELECT u FROM "
							+ DatabaseManagementEntity.class.getName()
							+ " u", DatabaseManagementEntity.class)
					.getResultList();
			if (entities == null || entities.isEmpty()) {
				DatabaseManagementEntity entity = new DatabaseManagementEntity();
				entity.setFinishedGenerating(flag);
				em.persist(entity);
			} else {
				DatabaseManagementEntity entity = entities.get(0);
				entity.setFinishedGenerating(flag);
			}
			em.getTransaction().commit();
		} finally {
			em.close();
		}
	}

	/**
	 * Returns true if the database has finished generating.
	 * False if it is currently generating.
	 * @return False if the database is generating.
	 */
	public boolean getGenerationFinishedFlag() {
		if (isMaintenanceMode()) {
			return false;
		}
		boolean finishedGenerating = false;
		EntityManager em = CategoryRepository.REPOSITORY.getEM();
		try {
			List<DatabaseManagementEntity> entities =
					em.createQuery("SELECT u FROM "
							+ DatabaseManagementEntity.class.getName()
							+ " u", DatabaseManagementEntity.class)
					.getResultList();
			if (entities != null && !entities.isEmpty()) {
				finishedGenerating = entities.get(0).isFinishedGenerating();
			}
		} finally {
			em.close();
		}
		return finishedGenerating;
	}

	/**
	 * Returns if the current persistence is in maintenance mode.
	 * Will return 503 on pretty much every external call in this mode.
	 * @return True if in maintenance, false otherwise.
	 */
	public boolean isMaintenanceMode() {
		return maintenanceMode;
	}

	/**
	 * Put the current persistence into maintenance mode.
	 * Will return 503 on pretty much every external call in this mode.
	 * @param maintenanceMode The maintenance flag.
	 */
	public synchronized void setMaintenanceModeInternal(boolean maintenanceMode) {
		this.maintenanceMode = maintenanceMode;
	}

	/**
	 * Puts all persistences into maintenance mode.
	 * Will return 503 on pretty much every external call once in this mode.
	 * @param maintenanceMode The maintenance flag.
	 */
	public void setMaintenanceModeGlobal(boolean maintenanceMode) {
		setMaintenanceModeInternal(maintenanceMode);
		List<Response> rs = ServiceLoadBalancer.multicastRESTToOtherServiceInstances(
				"generatedb", String.class, client -> setMaintenanceModeExternal(client, maintenanceMode));
		rs.forEach(r -> {
				if (r != null) {
					r.bufferEntity();
					r.close();
				}
			});
	}

	private Response setMaintenanceModeExternal(RESTClient<String> client, final Boolean maintenanceMode) {
		Response r = client.getEndpointTarget().path("maintenance")
		.request(MediaType.TEXT_PLAIN).post(Entity.entity(String.valueOf(maintenanceMode), MediaType.TEXT_PLAIN));
		return r;
	}
}

### END FILE ###

### FILE: repository\DatabaseManagementEntity.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;

/**
 * Entity for persisting database managenemt information in database.
 * @author Joakim von Kistowski
 *
 */
@Entity
public class DatabaseManagementEntity {

	@Id
	@GeneratedValue
	private long id;
	
	private boolean finishedGenerating;
	
	/**
	 * Create a new management entity.
	 */
	DatabaseManagementEntity() {
		finishedGenerating = false;
	}

	/**
	 * Get the id.
	 * @return the id
	 */
	long getId() {
		return id;
	}

	/**
	 * False if the database is currently being generated.
	 * True, otherwise.
	 * @return Database generation status.
	 */
	public boolean isFinishedGenerating() {
		return finishedGenerating;
	}

	/**
	 * Specify if the database has finished generating.
	 * False if the database is currently being generated, true otherwise.
	 * @param finishedGenerating Database generation status.
	 */
	public void setFinishedGenerating(boolean finishedGenerating) {
		this.finishedGenerating = finishedGenerating;
	}
	
}

### END FILE ###

### FILE: repository\EMFManager.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.repository;

import java.util.HashMap;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.Persistence;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Class for managing the EMF singleton.
 * @author Jóakim von Kistowski
 *
 */
final class EMFManager {

	private static EntityManagerFactory emf = null; 
	private static HashMap<String, String> persistenceProperties = null;
	
	private static final Logger LOG = LoggerFactory.getLogger(EMFManager.class);
	
	private static final String DRIVER_PROPERTY = "jakarta.persistence.jdbc.driver";
	private static final String IN_MEMORY_DRIVER_VALUE = "org.hsqldb.jdbcDriver";
	private static final String JDBC_URL_PROPERTY = "jakarta.persistence.jdbc.url";
	private static final String IN_MEMORY_JDBC_URL_VALUE = "jdbc:hsqldb:mem:test";
	private static final String USER_PROPERTY = "jakarta.persistence.jdbc.user";
	private static final String IN_MEMORY_USER_VALUE = "sa";
	private static final String PASSWORD_PROPERTY = "jakarta.persistence.jdbc.password";
	private static final String IN_MEMORY_PASSWORD_VALUE = "";
	
	private static final String MYSQL_URL_PREFIX = "jdbc:mysql://";
	private static final String MYSQL_URL_POSTFIX = "/teadb";
	private static final String MYSQL_DEFAULT_HOST = "localhost";
	private static final String MYSQL_DEFAULT_PORT = "3306";
	
	private EMFManager() {
		
	}
	
	/**
	 * (Re-)configure the entity manager factory using a set of persistence properties.
	 * Use to change database/user at run-time.
	 * Properties are kept, even if the database is reset.
	 * @param persistenceProperties The persistence properties.
	 */
	static void configureEMFWithProperties(HashMap<String, String> persistenceProperties) {
		EMFManager.persistenceProperties = persistenceProperties;
		clearEMF();
	}
	
	/**
	 * Get the entity manager factory.
	 * @return The entity manager factory.
	 */
	static synchronized EntityManagerFactory getEMF() {
		if (emf == null) {
			HashMap<String, String> persistenceProperties = EMFManager.persistenceProperties;
			if (persistenceProperties == null) {
				persistenceProperties = createPersistencePropertiesFromJavaEnv();
			}
			emf = Persistence.createEntityManagerFactory("tools.descartes.teastore.persistence",
					persistenceProperties);
			
		}
		return emf;
	}
	
	/**
	 * Closes and deletes EMF to be reinitialized later.
	 */
	static void clearEMF() {
		if (emf != null) {
			emf.close();
		}
		emf = null;
	}
	
	private static HashMap<String, String> createPersistencePropertiesFromJavaEnv() {
		HashMap<String, String> persistenceProperties = new HashMap<String, String>();
		String dbhost = null;
		String dbport = null;
		boolean useInMemoryDB = false;
		String url = MYSQL_URL_PREFIX;
		try {
			useInMemoryDB = Boolean.parseBoolean((String) new InitialContext().lookup("java:comp/env/inMemoryDB"));
			if (useInMemoryDB) {
				LOG.info("Using in-memory development database. Set Java env \"inMemoryDB\" to false to use MariaDB.");
			} else {
				LOG.info("\"inMemoryDB\" set to false. Using MariaDB/MySQL.");
			}
		} catch (NamingException e) {
			LOG.info("Using MySQL/MariaDB database.");
		}
		if (!useInMemoryDB) {
			try {
				dbhost = (String) new InitialContext().lookup("java:comp/env/databaseHost");
			} catch (NamingException e) {
				LOG.info("Database host not set. Falling back to default host at " + MYSQL_DEFAULT_HOST + ".");
			}
			try {
				dbport = (String) new InitialContext().lookup("java:comp/env/databasePort");
			} catch (NamingException e) {
				LOG.info("Database port not set. Falling back to default host at " + MYSQL_DEFAULT_PORT + ".");
			}
			if (dbhost != null || dbport != null) {
				if (dbhost != null) {
					url += dbhost;
				} else {
					url += MYSQL_DEFAULT_HOST;
				}
				url += ":";
				if (dbport != null) {
					url += dbport;
				} else {
					url += MYSQL_DEFAULT_PORT;
				}
				url += MYSQL_URL_POSTFIX;
				LOG.info("Setting jdbc url to \"" + url + "\".");
				persistenceProperties.put("jakarta.persistence.jdbc.url", url);
			}
		} else {
			persistenceProperties = createPersistencePropertieForInMemoryDB();
		}
		return persistenceProperties;
	}
	
	/**
	 * Create a persistence property map to configure the EMFManager to use an in-memory database
	 * instead of the usual MySQL/MariaDB database.
	 * @return The configuration. Pass this to {@link #configureEMFWithProperties(HashMap)}.
	 */
	static HashMap<String, String> createPersistencePropertieForInMemoryDB() {
		HashMap<String, String> persistenceProperties = new HashMap<String, String>();
		persistenceProperties.put(DRIVER_PROPERTY, IN_MEMORY_DRIVER_VALUE);
		persistenceProperties.put(JDBC_URL_PROPERTY, IN_MEMORY_JDBC_URL_VALUE);
		persistenceProperties.put(USER_PROPERTY, IN_MEMORY_USER_VALUE);
		persistenceProperties.put(PASSWORD_PROPERTY, IN_MEMORY_PASSWORD_VALUE);
		return persistenceProperties;
	}
}

### END FILE ###

### FILE: rest\CacheManagerEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import jakarta.ws.rs.DELETE;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;
import tools.descartes.teastore.persistence.repository.CacheManager;

/**
 * REST endpoint for cache clearing.
 * @author Joakim von Kistowski
 */
@Path("cache")
@Produces("text/plain")
public final class CacheManagerEndpoint {

	/**
	 * Clears the cache for the class.
	 * @param className fully qualified class name.
	 * @return Status Code 200 and cleared class name if clear succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path("/class/{class}")
	public Response clearClassCache(@PathParam("class") final String className) {
		boolean classfound = true;
		try {
			Class<?> entityClass = Class.forName(className);
			CacheManager.MANAGER.clearLocalCacheOnly(entityClass);
		} catch (Exception e) {
			classfound = false;
		}
		if (classfound) {
			return Response.ok(className).build();
		}
		return Response.status(Status.NOT_FOUND).build();
	}
	
	/**
	 * Clears the entire cache.
	 * @return Status Code 200 and "cleared" text if clear succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path("/cache")
	public Response clearAllCaches() {
		CacheManager.MANAGER.clearLocalCacheOnly();
		return Response.ok("cleared").build();
	}
	
	/**
	 * Closes and resets the EMF.
	 * @return Status Code 200 and "clearedEMF" text if reset succeeded, 404 if it didn't.
	 */
	@DELETE
	@Path("/emf")
	public Response clearEMF() {
		CacheManager.MANAGER.resetLocalEMF();
		return Response.ok("clearedEMF").build();
	}
}

### END FILE ###

### FILE: rest\CategoryEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.Path;

import tools.descartes.teastore.persistence.domain.CategoryRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Category;

/**
 * Persistence endpoint for CRUD operations on Categories.
 * @author Joakim von Kistowski
 *
 */
@Path("categories")
public class CategoryEndpoint extends AbstractCRUDEndpoint<Category> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Category category) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return CategoryRepository.REPOSITORY.createEntity(category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Category findEntityById(final long id) {
		Category category = CategoryRepository.REPOSITORY.getEntity(id);
		if (category == null) {
			return null;
		}
		return new Category(category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Category> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Category> categories = new ArrayList<Category>();
		for (Category c : CategoryRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			categories.add(new Category(c));
		}
		return categories;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Category category) {
		return CategoryRepository.REPOSITORY.updateEntity(id, category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return CategoryRepository.REPOSITORY.removeEntity(id);
	}
	
}

### END FILE ###

### FILE: rest\DatabaseGenerationEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.concurrent.Executors;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.persistence.repository.CacheManager;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.RegistryClient;

/**
 * Persistence endpoint for generating new database content.
 * @author Joakim von Kistowski
 *
 */
@Path("generatedb")
public class DatabaseGenerationEndpoint {

	private static final Logger LOG = LoggerFactory.getLogger(DatabaseGenerationEndpoint.class);

	/**
	 * Drop database and create a new one.
	 * @param categories Number of new categories.
	 * @param products Number of new products per category.
	 * @param users Number of new users.
	 * @param orders Number of max orders per user.
	 * @return Status OK. Returns {@value DataGenerator.MAINTENANCE_STATUS_CODE}
	 * if in maintenance mode.
	 */
	@GET
	public Response generateDataBase(
			@QueryParam("categories") final Integer categories,
			@QueryParam("products") final Integer products,
			@QueryParam("users") final Integer users,
			@QueryParam("orders") final Integer orders) {
		LOG.info("Received database generation command for Persistence at "
			+ RegistryClient.getClient().getMyServiceInstanceServer() + ".");
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return Response.status(DataGenerator.MAINTENANCE_STATUS_CODE).build();
		}
		DataGenerator.GENERATOR.setMaintenanceModeGlobal(true);
		LOG.info("Global maintenance mode enabled.");
		DataGenerator.GENERATOR.dropAndCreateTables();
		LOG.info("Finished dropping tables and re-initializing database schmema.");
		int categoryCount = parseQuery(categories, DataGenerator.SMALL_DB_CATEGORIES);
		int productCount = parseQuery(products, DataGenerator.SMALL_DB_PRODUCTS_PER_CATEGORY);
		int userCount = parseQuery(users, DataGenerator.SMALL_DB_USERS);
		int maxOrderCount = parseQuery(orders, DataGenerator.SMALL_DB_MAX_ORDERS_PER_USER);
		LOG.info("Initializing database creation with "
				+ categoryCount + " categories, "
				+ productCount + " products per category, "
				+ userCount + " users, "
				+ maxOrderCount + " max orders per user.");
		Executors.newSingleThreadScheduledExecutor().execute(() -> {
			DataGenerator.GENERATOR.generateDatabaseContent(categoryCount,
					productCount, userCount, maxOrderCount);
			LOG.info("Finished database generation.");
			CacheManager.MANAGER.resetRemoteEMFs();
			LOG.info("Finished resetting all Persistence service instances.");
			DataGenerator.GENERATOR.setMaintenanceModeGlobal(false);
			LOG.info("Done. Maintenance mode disabled.");
		});
		String message = "Creating database with "
				+ categoryCount + " categories, "
				+ productCount + " products per category, "
				+ userCount + " users, "
				+ maxOrderCount + " max orders per user.";
		return Response.ok(message).build();
	}

	private int parseQuery(Integer param, int defaultValue) {
		if (param == null) {
			return defaultValue;
		}
		return param;
	}

	/**
	 * Returns the is finished flag for database generation.
	 * Also returns false if the persistence provider is in maintenance mode.
	 * @return True, if generation is finished; false, if in progress.
	 */
	@GET
	@Path("finished")
	public Response isFinshed() {
		if (DataGenerator.GENERATOR.getGenerationFinishedFlag()) {
			return Response.ok(true).build();
		} else {
			return Response.serverError().entity(false).build();
		}
	}

	/**
	 * Disables or enables the maintenance mode.
	 * Persistence providers in maintenance mode return 503 on almost anything.
	 * @param maintenanceMode Send true to enable, false to disable.
	 * @return 404 if message body was missing. 200, otherwise.
	 */
	@POST
	@Path("maintenance")
	public Response setMaintenanceMode(final Boolean maintenanceMode) {
		if (maintenanceMode == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		DataGenerator.GENERATOR.setMaintenanceModeInternal(maintenanceMode);
		return Response.ok().build();
	}

	/**
	 * Returns the is maintenance flag. Only to be used by other persistence providers.
	 * @return True, if in maintenance; false, otherwise.
	 */
	@GET
	@Path("maintenance")
	public Response isMaintenance() {
		return Response.ok(DataGenerator.GENERATOR.isMaintenanceMode()).build();
	}
}

### END FILE ###

### FILE: rest\OrderEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;

import tools.descartes.teastore.persistence.domain.OrderRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Order;

/**
 * Persistence endpoint for for CRUD operations on orders.
 * @author Joakim von Kistowski
 *
 */
@Path("orders")
public class OrderEndpoint extends AbstractCRUDEndpoint<Order> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Order order) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return OrderRepository.REPOSITORY.createEntity(order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Order findEntityById(final long id) {
		Order order = OrderRepository.REPOSITORY.getEntity(id);
		if (order == null) {
			return null;
		}
		return new Order(order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Order> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Order> order = new ArrayList<Order>();
		for (Order o : OrderRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			order.add(new Order(o));
		}
		return order;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Order order) {
		return OrderRepository.REPOSITORY.updateEntity(id, order);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return OrderRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all order items with the given product Id (all order items for that product).
	 * @param userId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path("user/{user:[0-9][0-9]*}")
	public List<Order> listAllForUser(@PathParam("user") final Long userId,
			@QueryParam("start") final Integer startPosition,
			@QueryParam("max") final Integer maxResult) {
		if (userId == null) {
			return listAll(startPosition, maxResult);
		}
		List<Order> orders = new ArrayList<Order>();
		for (Order o : OrderRepository.REPOSITORY.getAllEntitiesWithUser(userId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orders.add(new Order(o));
		}
		return orders;
	}

}

### END FILE ###

### FILE: rest\OrderItemEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;

import tools.descartes.teastore.persistence.domain.OrderItemRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.OrderItem;

/**
 * Persistence endpoint for for CRUD operations on orders.
 * @author Joakim von Kistowski
 *
 */
@Path("orderitems")
public class OrderItemEndpoint extends AbstractCRUDEndpoint<OrderItem> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final OrderItem orderItem) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return OrderItemRepository.REPOSITORY.createEntity(orderItem);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected OrderItem findEntityById(final long id) {
		OrderItem item = OrderItemRepository.REPOSITORY.getEntity(id);
		if (item == null) {
			return null;
		}
		return new OrderItem(item);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<OrderItem> listAllEntities(final int startIndex, final int maxResultCount) {
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, OrderItem orderItem) {
		return OrderItemRepository.REPOSITORY.updateEntity(id, orderItem);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return OrderItemRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all order items with the given product Id (all order items for that product).
	 * @param productId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path("product/{product:[0-9][0-9]*}")
	public List<OrderItem> listAllForProduct(@PathParam("product") final Long productId,
			@QueryParam("start") final Integer startPosition,
			@QueryParam("max") final Integer maxResult) {
		if (productId == null) {
			return listAll(startPosition, maxResult);
		}
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntitiesWithProduct(productId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}
	
	/**
	 * Returns all order items with the given order Id (all order items for that order).
	 * @param orderId The id of the product.
	 * @param startPosition The index (NOT ID) of the first order item with the product to return.
	 * @param maxResult The max number of order items to return.
	 * @return list of order items with the product.
	 */
	@GET
	@Path("order/{order:[0-9][0-9]*}")
	public List<OrderItem> listAllForOrder(@PathParam("order") final Long orderId,
			@QueryParam("start") final Integer startPosition,
			@QueryParam("max") final Integer maxResult) {
		if (orderId == null) {
			return listAll(startPosition, maxResult);
		}
		List<OrderItem> orderItems = new ArrayList<OrderItem>();
		for (OrderItem oi : OrderItemRepository.REPOSITORY.getAllEntitiesWithOrder(orderId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			orderItems.add(new OrderItem(oi));
		}
		return orderItems;
	}
}

### END FILE ###

### FILE: rest\ProductEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.persistence.domain.ProductRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.Product;

/**
 * Persistence endpoint for for CRUD operations on products.
 * @author Joakim von Kistowski
 *
 */
@Path("products")
public class ProductEndpoint extends AbstractCRUDEndpoint<Product> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final Product product) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		return ProductRepository.REPOSITORY.createEntity(product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected Product findEntityById(final long id) {
		Product product = ProductRepository.REPOSITORY.getEntity(id);
		if (product == null) {
			return null;
		}
		return new Product(product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<Product> listAllEntities(final int startIndex, final int maxResultCount) {
		List<Product> products = new ArrayList<Product>();
		for (Product p : ProductRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			products.add(new Product(p));
		}
		return products;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, Product product) {
		return ProductRepository.REPOSITORY.updateEntity(id, product);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return ProductRepository.REPOSITORY.removeEntity(id);
	}
	
	/**
	 * Returns all products with the given category Id (all products in that category).
	 * @param categoryId The id of the Category.
	 * @param startPosition The index (NOT ID) of the first product in the category to return.
	 * @param maxResult The max number of products to return.
	 * @return list of products in the category.
	 */
	@GET
	@Path("category/{category:[0-9][0-9]*}")
	public List<Product> listAllForCategory(@PathParam("category") final Long categoryId,
			@QueryParam("start") final Integer startPosition,
			@QueryParam("max") final Integer maxResult) {
		if (categoryId == null) {
			return listAll(startPosition, maxResult);
		}
		List<Product> products = new ArrayList<Product>();
		for (Product p : ProductRepository.REPOSITORY.getAllEntities(categoryId,
				parseIntQueryParam(startPosition), parseIntQueryParam(maxResult))) {
			products.add(new Product(p));
		}
		return products;
	}
	
	/**
	 * Returns the count of produts with the given category Id (products in that category).
	 * @param categoryId The id of the Category.
	 * @return list of products in the category.
	 */
	@GET
	@Path("count/{category:[0-9][0-9]*}")
	public Response countForCategory(@PathParam("category") final Long categoryId) {
		if (categoryId == null) {
			return Response.status(404).build();
		}
		long count = ProductRepository.REPOSITORY.getProductCount(categoryId);
		if (count >= 0) {
			return Response.ok(String.valueOf(count)).build();
		}
		return Response.status(404).build();
	}
}

### END FILE ###

### FILE: rest\UserEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.rest;

import java.util.ArrayList;
import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.Response.Status;

import tools.descartes.teastore.persistence.domain.UserRepository;
import tools.descartes.teastore.persistence.repository.DataGenerator;
import tools.descartes.teastore.registryclient.util.AbstractCRUDEndpoint;
import tools.descartes.teastore.entities.User;

/**
 * Persistence endpoint for CRUD operations on Categories.
 * 
 * @author Joakim von Kistowski
 *
 */
@Path("users")
public class UserEndpoint extends AbstractCRUDEndpoint<User> {

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected long createEntity(final User category) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return -1L;
		}
		try {
			return UserRepository.REPOSITORY.createEntity(category);
		} catch (Exception e) {
			// SQL errors, especially for duplicate user names
			return -1L;
		}

	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected User findEntityById(final long id) {
		User user = UserRepository.REPOSITORY.getEntity(id);
		if (user == null) {
			return null;
		}
		return new User(user);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected List<User> listAllEntities(final int startIndex, final int maxResultCount) {
		List<User> users = new ArrayList<User>();
		for (User u : UserRepository.REPOSITORY.getAllEntities(startIndex, maxResultCount)) {
			users.add(new User(u));
		}
		return users;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean updateEntity(long id, User category) {
		return UserRepository.REPOSITORY.updateEntity(id, category);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected boolean deleteEntity(long id) {
		if (DataGenerator.GENERATOR.isMaintenanceMode()) {
			return false;
		}
		return UserRepository.REPOSITORY.removeEntity(id);
	}

	/**
	 * Retreive user with the provided name.
	 * 
	 * @param name
	 *            name of the entity to find.
	 * @return A Response containing the entity.
	 */
	@GET
	@Path("name/{name}")
	public Response findById(@PathParam("name") final String name) {
		if (name == null || name.isEmpty()) {
			return Response.status(Status.NOT_FOUND).build();
		}
		User entity = UserRepository.REPOSITORY.getUserByName(name);
		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		return Response.ok(new User(entity)).build();
	}
}

### END FILE ###

### FILE: servlet\IndexServlet.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.persistence.servlet;

import java.io.IOException;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Index Servlet for Persistence. Provides some basic debug information for
 * deployers and testers.
 * @author Joakim von Kistowski
 */
@WebServlet("/index")
public class IndexServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
       
    /**
     * @see HttpServlet#HttpServlet()
     */
    public IndexServlet() {
        super();
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.getWriter().println("This is the persistence module running at "
	+ request.getProtocol() + "://" + request.getLocalAddr() + ":"
				+ request.getLocalPort() + "/" + request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 * @param request The request.
	 * @param response The response.
	 * @throws ServletException In case of servlet Exception.
	 * @throws IOException In case of IOException.
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}

### END FILE ###

