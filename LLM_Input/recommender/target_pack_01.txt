### MANIFESTO - RECOMMENDER SERVICE REFACTORING ###
- Role: Senior Architect
- Target Module: tools.descartes.teastore.recommender
- Architecture: JAX-RS (Jersey)
- Guardrails: 
  1. API Stability: Do NOT change @Path or public method signatures.
  2. Structural Integrity: Do NOT modify interfaces/entities modülü.
  3. No New Dependencies: Stay within the current pom.xml limits.
- Principles: Focus on High Cohesion, Low Coupling, and Single Responsibility.
- Output: Return only changed files in ### FILE: <path> ... ### END FILE format.

### FILE: algorithm\AbstractRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Abstract class for basic recommendation functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public abstract class AbstractRecommender implements IRecommender {

	private boolean trainingFinished = false;

	/**
	 * Defines the maximum number of recommendations different implementations
	 * should return. Is NOT mandatory for any of the algorithms.
	 */
	public static final int MAX_NUMBER_OF_RECOMMENDATIONS = 10;

	private static final Logger LOG = LoggerFactory.getLogger(AbstractRecommender.class);

	/**
	 * This represents the matrix assigning each user a frequency for each product
	 * ID. The frequency resembles the number of times, a user has bought that item.
	 */
	private Map<Long, Map<Long, Double>> userBuyingMatrix;

	/**
	 * This set maps a userId to a set, containing the corresponding OrderItemSets,
	 * i.e. all orders that were done by the user.
	 */
	private Map<Long, Set<OrderItemSet>> userItemSets;

	/**
	 * This is an enumeration of all available products seen during the training
	 * phase.
	 */
	private Set<Long> totalProducts;

	@Override
	public void train(List<OrderItem> orderItems, List<Order> orders) {
		long tic = System.currentTimeMillis();
		totalProducts = new HashSet<>();
		// first create order mapping unorderized
		Map<Long, OrderItemSet> unOrderizeditemSets = new HashMap<>();
		for (OrderItem orderItem : orderItems) {
			if (!unOrderizeditemSets.containsKey(orderItem.getOrderId())) {
				unOrderizeditemSets.put(orderItem.getOrderId(), new OrderItemSet());
				unOrderizeditemSets.get(orderItem.getOrderId()).setOrderId(orderItem.getOrderId());
			}
			unOrderizeditemSets.get(orderItem.getOrderId()).getOrderset().put(orderItem.getProductId(),
					orderItem.getQuantity());
			// see, if we already have our item
			if (!totalProducts.contains(orderItem.getProductId())) {
				// if not known yet -> add
				totalProducts.add(orderItem.getProductId());
			}
		}
		// now map each id with the corresponding order
		Map<Order, OrderItemSet> itemSets = new HashMap<>();
		for (Long orderid : unOrderizeditemSets.keySet()) {
			Order realOrder = findOrder(orders, orderid);
			itemSets.put(realOrder, unOrderizeditemSets.get(orderid));
		}
		userItemSets = new HashMap<>();
		for (Order order : itemSets.keySet()) {
			if (!userItemSets.containsKey(order.getUserId())) {
				userItemSets.put(order.getUserId(), new HashSet<OrderItemSet>());
			}
			itemSets.get(order).setUserId(order.getUserId());
			userItemSets.get(order.getUserId()).add(itemSets.get(order));
		}
		userBuyingMatrix = createUserBuyingMatrix(userItemSets);
		executePreprocessing();
		LOG.info("Training recommender finished. Training took: " + (System.currentTimeMillis() - tic) + "ms.");
		trainingFinished = true;
	}

	/**
	 * Triggers implementing classes if they want to execute a pre-processing step
	 * during {@link AbstractRecommender#train(List, List)}.
	 */
	protected void executePreprocessing() {
		// do nothing
	}

	@Override
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems)
			throws UnsupportedOperationException {
		if (!trainingFinished) {
			throw new UnsupportedOperationException("This instance is not fully trained yet.");
		}
		if (currentItems.isEmpty()) {
			// if input is empty return empty list
			return new LinkedList<>();
		}
		List<Long> items = new ArrayList<>(currentItems.size());
		for (OrderItem item : currentItems) {
			items.add(item.getProductId());
		}
		return execute(userid, items);
	}

	/**
	 * Filters the given ranking of recommendations and deletes items that already
	 * are in the cart. Furthermore caps the recommendations and only uses the
	 * {@link AbstractRecommender#MAX_NUMBER_OF_RECOMMENDATIONS} highest rated
	 * recommendations.
	 * 
	 * @param priorityList
	 *            The unfiltered ranking assigning each recommended product ID a
	 *            score or an importance. Does not need to be sorted.
	 * @param currentItems
	 *            The list of item IDs that must NOT be contained in the returned
	 *            list.
	 * @return A sorted list of recommendations with a size not greater than
	 *         {@link AbstractRecommender#MAX_NUMBER_OF_RECOMMENDATIONS}
	 */
	protected List<Long> filterRecommendations(Map<Long, Double> priorityList, List<Long> currentItems) {
		TreeMap<Double, List<Long>> ranking = createRanking(priorityList);
		List<Long> reco = new ArrayList<>(MAX_NUMBER_OF_RECOMMENDATIONS);
		for (Double score : ranking.descendingKeySet()) {
			List<Long> productIds = ranking.get(score);
			for (long productId : productIds) {
				if (reco.size() < MAX_NUMBER_OF_RECOMMENDATIONS) {
					if (!currentItems.contains(productId)) {
						reco.add(productId);
					}
				} else {
					return reco;
				}
			}
		}
		return reco;
	}

	private TreeMap<Double, List<Long>> createRanking(Map<Long, Double> map) {
		// transforming the map into a treemap (for efficient access)
		TreeMap<Double, List<Long>> ranking = new TreeMap<Double, List<Long>>();
		for (Entry<Long, Double> entry : map.entrySet()) {
			List<Long> productIds = ranking.get(entry.getValue());
			if (productIds == null) {
				productIds = new ArrayList<>();
				ranking.put(entry.getValue(), productIds);
			}
			productIds.add(entry.getKey());
		}
		return ranking;
	}

	/**
	 * Has to be implemented by subclasses in order to perform actual
	 * recommendation.
	 * 
	 * @param userid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @param currentItems
	 *            A list containing all ids of {@link OrderItem}s.
	 * @return List of all IDs of the {@link Product} entities that are recommended
	 *         to add to the cart. Does not contain any {@link Product} that is
	 *         already part of the given list of {@link OrderItem}s. Might be empty.
	 */
	protected abstract List<Long> execute(Long userid, List<Long> currentItems);

	private Order findOrder(List<Order> orders, long orderid) {
		for (Order order : orders) {
			if (order.getId() == orderid) {
				return order;
			}
		}
		return null;
	}

	/**
	 * @return the userBuyingMatrix
	 */
	public Map<Long, Map<Long, Double>> getUserBuyingMatrix() {
		return userBuyingMatrix;
	}

	/**
	 * @param userBuyingMatrix
	 *            the userBuyingMatrix to set
	 */
	public void setUserBuyingMatrix(Map<Long, Map<Long, Double>> userBuyingMatrix) {
		this.userBuyingMatrix = userBuyingMatrix;
	}

	/**
	 * @return the totalProducts
	 */
	public Set<Long> getTotalProducts() {
		return totalProducts;
	}

	/**
	 * @param totalProducts
	 *            the totalProducts to set
	 */
	public void setTotalProducts(Set<Long> totalProducts) {
		this.totalProducts = totalProducts;
	}

	/**
	 * @return the userItemSets
	 */
	public Map<Long, Set<OrderItemSet>> getUserItemSets() {
		return userItemSets;
	}

	/**
	 * @param userItemSets
	 *            the userItemSets to set
	 */
	public void setUserItemSets(Map<Long, Set<OrderItemSet>> userItemSets) {
		this.userItemSets = userItemSets;
	}

	/**
	 * Transforms the list of orders into one matrix containing all user-IDs and
	 * their number of buys (i.e., their rating) of all product-IDs. A
	 * quantity/rating of a user is null, if the user did not buy that item. If the
	 * user bought one item at least once, the contained value (rating) is the
	 * number of times, he bought one given item.
	 * 
	 * @param useritemsets
	 *            A map assigning each user-ID all its OrderItemSets
	 * @return A Map representing a matrix of each user-ID assigning each item-ID
	 *         its number of buys (as double value)
	 */
	private static Map<Long, Map<Long, Double>> createUserBuyingMatrix(Map<Long, Set<OrderItemSet>> useritemsets) {
		Map<Long, Map<Long, Double>> matrix = new HashMap<>();
		// for each user
		for (Entry<Long, Set<OrderItemSet>> entry : useritemsets.entrySet()) {
			// create a new line for this user-ID
			Map<Long, Double> line = new HashMap<>();
			// for all orders of that user
			for (OrderItemSet orderset : entry.getValue()) {
				// for all orderitems of that orderset
				for (Entry<Long, Integer> product : orderset.getOrderset().entrySet()) {
					// if key was not known before -> first occurence
					if (!line.containsKey(product.getKey())) {
						line.put(product.getKey(), Double.valueOf(product.getValue()));
					} else {
						// if key was known before -> increase counter
						line.put(product.getKey(), Double.valueOf(line.get(product.getKey()) + product.getValue()));
					}
				}
			}
			// add this user-ID to the matrix
			matrix.put(entry.getKey(), line);
		}
		return matrix;
	}

}

### END FILE ###

### FILE: algorithm\IRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.List;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Interface providing the recommender functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public interface IRecommender {

	/**
	 * Trains this recommender with the given list of historical {@link OrderItems}s
	 * and {@link Order}s. This list is used as knowledge basis for the recommending
	 * in {@link IRecommender#recommendProducts(List)}.<br>
	 * The mapping of the different {@link OrderItem}s to their corresponding
	 * {@link Order}s is done via {@link OrderItem#getOrderId()}.<br>
	 * Calling this method twice will trigger a retraining.
	 * 
	 * @param orderItems
	 *            A list of {@link OrderItem}s that were placed by users.
	 * @param orders
	 *            A list of {@link Order}s that were placed by users.
	 */
	public void train(List<OrderItem> orderItems, List<Order> orders);

	/**
	 * Return a list of all {@link Product}s, which are recommended for the given
	 * {@link User} buying the given list of {@link OrderItem}s. <br>
	 * {@link IRecommender#train(List)} must be called before any recommendations
	 * can be executed.
	 * 
	 * @param currentItems
	 *            A list containing all {@link OrderItem}s in the current cart.
	 *            Might be empty.
	 * @param userid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of all IDs of the {@link Product} entities that are recommended
	 *         to add to the cart. Does not contain any {@link Product} that is
	 *         already part of the given list of {@link OrderItem}s. Might be empty.
	 * 
	 * @throws UnsupportedOperationException
	 *             If this instance is not ready to recommend, i.e.,
	 *             {@link IRecommender#train(List)} has not been invoked or
	 *             terminated yet.
	 */
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems) throws UnsupportedOperationException;

}

### END FILE ###

### FILE: algorithm\OrderItemSet.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.util.HashMap;
import java.util.Map;

import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Objects of this class holds a mapping of {@link Product} IDs to quantities
 * that were bought in the same {@link Order} by one {@link User}. Non-present
 * {@link Product} IDs imply a quantity of 0.
 * 
 * @author Johannes Grohmann
 *
 */
public class OrderItemSet {

	/**
	 * Standard constructor.
	 */
	public OrderItemSet() {
		orderset = new HashMap<>();
	}

	/**
	 * The user that made this order.
	 */
	private long userId;

	/**
	 * The orderId that the Items were bought in.
	 */
	private long orderId;

	/**
	 * The productIds that were bought together with the given quantity.
	 */
	private Map<Long, Integer> orderset;

	/**
	 * @return the orderset
	 */
	public Map<Long, Integer> getOrderset() {
		return orderset;
	}

	/**
	 * @param orderset
	 *            the orderset to set
	 */
	public void setOrderset(Map<Long, Integer> orderset) {
		this.orderset = orderset;
	}

	/**
	 * @return the orderId
	 */
	public long getOrderId() {
		return orderId;
	}

	/**
	 * @param orderId
	 *            the orderId to set
	 */
	public void setOrderId(long orderId) {
		this.orderId = orderId;
	}

	/**
	 * @return the userId
	 */
	public long getUserId() {
		return userId;
	}

	/**
	 * @param userId the userId to set
	 */
	public void setUserId(long userId) {
		this.userId = userId;
	}
}

### END FILE ###

### FILE: algorithm\RecommenderSelector.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.naming.InitialContext;
import javax.naming.NamingException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;
import tools.descartes.teastore.recommender.algorithm.impl.cf.PreprocessedSlopeOneRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.cf.SlopeOneRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.orderbased.OrderBasedRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.pop.PopularityBasedRecommender;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * A strategy selector for the Recommender functionality.
 * 
 * @author Johannes Grohmann
 *
 */
public final class RecommenderSelector implements IRecommender {

	/**
	 * This map lists all currently available recommending approaches and assigns
	 * them their "name" for the environment variable.
	 */
	private static Map<String, Class<? extends IRecommender>> recommenders = new HashMap<>();

	static {
		recommenders = new HashMap<String, Class<? extends IRecommender>>();
		recommenders.put("Popularity", PopularityBasedRecommender.class);
		recommenders.put("SlopeOne", SlopeOneRecommender.class);
		recommenders.put("PreprocessedSlopeOne", PreprocessedSlopeOneRecommender.class);
		recommenders.put("OrderBased", OrderBasedRecommender.class);
	}

	/**
	 * The default recommender to choose, if no other recommender was set.
	 */
	private static final Class<? extends IRecommender> DEFAULT_RECOMMENDER = SlopeOneRecommender.class;

	private static final Logger LOG = LoggerFactory.getLogger(RecommenderSelector.class);

	private static RecommenderSelector instance;

	private IRecommender fallbackrecommender;

	private IRecommender recommender;

	/**
	 * Private Constructor.
	 */
	private RecommenderSelector() {
		fallbackrecommender = new PopularityBasedRecommender();
		try {
			String recommendername = (String) new InitialContext().lookup("java:comp/env/recommenderAlgorithm");
			// if a specific algorithm is set, we can use that algorithm
			if (recommenders.containsKey(recommendername)) {
				try {
					recommender = recommenders.get(recommendername).getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				} catch (NoSuchMethodException e) {
					e.printStackTrace();
				} catch (SecurityException e) {
					e.printStackTrace();
				}
			} else {
				LOG.warn("Recommendername: " + recommendername
						+ " was not found. Using default recommender (SlopeOneRecommeder).");
				try {
					recommender = DEFAULT_RECOMMENDER.getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				} catch (NoSuchMethodException e) {
					e.printStackTrace();
				} catch (SecurityException e) {
					e.printStackTrace();
				}
			}
		} catch (InstantiationException | IllegalAccessException e) {
			// if creating a new instance fails
			e.printStackTrace();
			LOG.warn("Could not create an instance of the requested recommender. Using fallback.");
			recommender = fallbackrecommender;
		} catch (NamingException e) {
			// if nothing was set
			LOG.info("Recommender not set. Using default recommender (SlopeOneRecommeder).");
			try {
				try {
					recommender = DEFAULT_RECOMMENDER.getDeclaredConstructor().newInstance();
				} catch (IllegalArgumentException e1) {
					e1.printStackTrace();
				} catch (InvocationTargetException e1) {
					e1.printStackTrace();
				} catch (NoSuchMethodException e1) {
					e1.printStackTrace();
				} catch (SecurityException e1) {
					e1.printStackTrace();
				}
			} catch (InstantiationException | IllegalAccessException e1) {
				// also the default algorithm could fail
				e1.printStackTrace();
				LOG.warn("Could not create an instance of DEFAULT_RECOMMENDER " + DEFAULT_RECOMMENDER.getName() + ".");
				recommender = fallbackrecommender;
			}
		}
	}

	@Override
	public List<Long> recommendProducts(Long userid, List<OrderItem> currentItems)
			throws UnsupportedOperationException {
		try {
			return recommender.recommendProducts(userid, currentItems);
		} catch (UseFallBackException e) {
			// a UseFallBackException is usually ignored (as it is conceptual and might
			// occur quite often)
			LOG.trace("Executing " + recommender.getClass().getName()
					+ " as recommender failed. Using fallback recommender. Reason:\n" + e.getMessage());
			return fallbackrecommender.recommendProducts(userid, currentItems);
		} catch (UnsupportedOperationException e) {
			// if algorithm is not yet trained, we throw the error
			LOG.error("Executing " + recommender.getClass().getName()
					+ " threw an UnsupportedOperationException. The recommender was not finished with training.");
			throw e;
		} catch (Exception e) {
			// any other exception is just reported
			LOG.warn("Executing " + recommender.getClass().getName()
					+ " threw an unexpected error. Using fallback recommender. Reason:\n" + e.getMessage());
			return fallbackrecommender.recommendProducts(userid, currentItems);
		}
	}

	/**
	 * Returns the instance of this Singleton or creates a new one, if this is the
	 * first call of this method.
	 * 
	 * @return The instance of this class.
	 */
	public static synchronized RecommenderSelector getInstance() {
		if (instance == null) {
			 instance = new RecommenderSelector();
		}
		return instance;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.IRecommender#train(java.util.List,
	 * java.util.List)
	 */
	@Override
	public void train(List<OrderItem> orderItems, List<Order> orders) {
		recommender.train(orderItems, orders);
		fallbackrecommender.train(orderItems, orders);
	}

}

### END FILE ###

### FILE: algorithm\impl\DummyRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl;

import java.util.ArrayList;
import java.util.List;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;

/**
 * Temporary class to be replaced by something actually useful.
 * 
 * @author Johannes Grohmann
 *
 */
public class DummyRecommender extends AbstractRecommender {
	
	/* (non-Javadoc)
	 * @see tools.descartes.teastore.recommender.algorithm.AbstractRecommender#execute(java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		List<Long> recommended = new ArrayList<Long>();
		recommended.add(-1L);
		return recommended;
	}

}

### END FILE ###

### FILE: algorithm\impl\UseFallBackException.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl;

/**
 * This exception signals a (mostly) conceptual error or lack of information,
 * why the current recommending approach can not be applied. Therefore the
 * calling instance should go for the robust fall-back solution in this case.
 * 
 * @author Johannes
 *
 */
public class UseFallBackException extends RuntimeException {

	/**
	 * @param string
	 *            The error message.
	 */
	public UseFallBackException(String string) {
		super(string);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 2503876420753158905L;

}

### END FILE ###

### FILE: algorithm\impl\cf\PreprocessedSlopeOneRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.cf;

import java.util.HashMap;
import java.util.Map;

/**
 * Recommender based on item-based collaborative filtering with the slope one
 * algorithm.
 * 
 * @author Johannes Grohmann
 *
 */
public class PreprocessedSlopeOneRecommender extends SlopeOneRecommender {

	/**
	 * Represents a matrix, assigning each user a calculated score for each item.
	 * This score can be used to recommend items.
	 */
	private Map<Long, Map<Long, Double>> predictedRatings;

	/**
	 * @return the predictedRatings
	 */
	public Map<Long, Map<Long, Double>> getPredictedRatings() {
		return predictedRatings;
	}

	/**
	 * @param predictedRatings
	 *            the predictedRatings to set
	 */
	public void setPredictedRatings(Map<Long, Map<Long, Double>> predictedRatings) {
		this.predictedRatings = predictedRatings;
	}

	@Override
	protected Map<Long, Double> getUserVector(Long userid) {
		// improve performance by preprocessing and storing userids
		return predictedRatings.get(userid);
	}

	@Override
	protected void executePreprocessing() {
		super.executePreprocessing();
		predictedRatings = new HashMap<>();
		// Moving the matrix calculation to the preprocessing to optimize runtime
		// behavior
		for (Long userid : getUserBuyingMatrix().keySet()) {
			// for all known users
			Map<Long, Double> pred = super.getUserVector(userid);
			predictedRatings.put(userid, pred);
		}
	}
}

### END FILE ###

### FILE: algorithm\impl\cf\SlopeOneRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.cf;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;
import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;

/**
 * Recommender based on item-based collaborative filtering with the slope one
 * algorithm.
 * 
 * @author Johannes Grohmann
 *
 */
public class SlopeOneRecommender extends AbstractRecommender {

	/**
	 * Represents a matrix, assigning each itemid an average difference (in
	 * rating/buying) to any other itemid.
	 */
	private Map<Long, Map<Long, Double>> differences = new HashMap<>();

	/**
	 * Represents a matrix, counting the frequencies of each combination (i.e. users
	 * rating/buying both items).
	 */
	private Map<Long, Map<Long, Integer>> frequencies = new HashMap<>();

	/**
	 * @return the differences
	 */
	public Map<Long, Map<Long, Double>> getDifferences() {
		return differences;
	}

	/**
	 * @param differences
	 *            the differences to set
	 */
	public void setDifferences(Map<Long, Map<Long, Double>> differences) {
		this.differences = differences;
	}

	/**
	 * @return the frequencies
	 */
	public Map<Long, Map<Long, Integer>> getFrequencies() {
		return frequencies;
	}

	/**
	 * @param frequencies
	 *            the frequencies to set
	 */
	public void setFrequencies(Map<Long, Map<Long, Integer>> frequencies) {
		this.frequencies = frequencies;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute(java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		if (userid == null) {
			throw new UseFallBackException(this.getClass().getName()
					+ " does not support null userids. Use a pseudouser or switch to another approach.");
		}
		if (getUserBuyingMatrix().get(userid) == null) {
			// this user has not bought anything yet, so we do not have any information
			throw new UseFallBackException("No user information.");
		}
		Map<Long, Double> importances = getUserVector(userid);
		return filterRecommendations(importances, currentItems);

	}

	/**
	 * Generates one row of the matrix for the given user. (Predicts the user score
	 * for each product ID.)
	 * 
	 * @param userid
	 *            The user to predict for
	 * @return A Map assigning each product ID a (predicted) score (for the given
	 *         user)
	 */
	protected Map<Long, Double> getUserVector(Long userid) {
		// This could be further optimized by moving this part into the pre-processing
		// step, but we want to have nicer performance behavior
		HashMap<Long, Double> importances = new HashMap<>();
		for (Long productid : getTotalProducts()) {
			try {
				importances.put(productid, calculateScoreForItem(userid, productid));
			} catch (NullPointerException e) {
				// this exception can be thrown if we have not enough information
				importances.put(productid, -1.0);
			}
		}
		return importances;
	}

	private double calculateScoreForItem(long userid, long itemid) {
		double score = 0;
		double cumWeights = 0;
		for (Entry<Long, Double> useritem : getUserBuyingMatrix().get(userid).entrySet()) {
			// if we find that the user actually bought this item before, we can return this
			// value
			// (considering it is his rating, we can directly return this rating)
			if (useritem.getKey() == itemid) {
				return useritem.getValue();
			}
			// if not, we can calculate the (expected) rating for that user based on item i
			int frequency = frequencies.get(useritem.getKey()).get(itemid);
			score += useritem.getValue() * frequency;
			score += differences.get(useritem.getKey()).get(itemid) * frequency;
			cumWeights += frequency;
		}
		// normalize
		return score / cumWeights;
	}

	@Override
	protected void executePreprocessing() {
		// The buying matrix is considered to be the rating
		// i.e. the more buys, the higher the rating
		buildDifferencesMatrices(getUserBuyingMatrix());
	}

	/**
	 * Based on the available data, calculate the relationships between the items
	 * and number of occurrences. Fill the difference and frequencies matrix.
	 * 
	 * @param data
	 *            The user rating matrix
	 */
	private void buildDifferencesMatrices(Map<Long, Map<Long, Double>> userRatingMatrix) {
		for (Map<Long, Double> uservalues : userRatingMatrix.values()) {
			for (Entry<Long, Double> singleRating : uservalues.entrySet()) {
				// if not present -> create
				if (!frequencies.containsKey(singleRating.getKey())) {
					frequencies.put(singleRating.getKey(), new HashMap<Long, Integer>());
					differences.put(singleRating.getKey(), new HashMap<Long, Double>());
				}
				// for all other ratings of that user
				for (Entry<Long, Double> otherRating : uservalues.entrySet()) {
					int currCount = 0;
					Integer count = frequencies.get(singleRating.getKey()).get(otherRating.getKey());
					if (count != null) {
						// count is != null, if the key is actually found
						// if so, we use the known count value as count, otherwise the count until now
						// is 0
						currCount = count.intValue();
					}

					double currDiff = 0;
					Double diff = differences.get(singleRating.getKey()).get(otherRating.getKey());
					if (diff != null) {
						// diff is != null, if the key is actually found
						// if so, we use the known difference value as currDiff, otherwise the diff
						// until now is 0.0
						currDiff = diff.doubleValue();
					}

					// get the diff value of this user
					double userdiff = singleRating.getValue() - otherRating.getValue();
					frequencies.get(singleRating.getKey()).put(otherRating.getKey(), currCount + 1);
					differences.get(singleRating.getKey()).put(otherRating.getKey(), currDiff + userdiff);
				}
			}
		}

		// now, transform the differences matrix into real differences (not just the sum
		// of all found differences)
		for (Long i : differences.keySet()) {
			for (Long j : differences.get(i).keySet()) {
				// for all matrix entries divide the differences by the sum of occurences
				double diffval = differences.get(i).get(j);
				double freq = frequencies.get(i).get(j);
				differences.get(i).put(j, diffval / freq);
			}
		}
	}
}

### END FILE ###

### FILE: algorithm\impl\orderbased\OrderBasedRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.orderbased;

import java.util.HashMap;
import java.util.List;
import java.util.Set;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;
import tools.descartes.teastore.recommender.algorithm.OrderItemSet;
import tools.descartes.teastore.recommender.algorithm.impl.UseFallBackException;

/**
 * A simple Recommender that makes recommendations based on an order-based
 * nearest-neighbor heuristic.
 * 
 * @author Johannes Grohmann
 *
 */
public class OrderBasedRecommender extends AbstractRecommender {

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute( java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		// Map with all product IDs and how often they have been bought in the same cart
		// with one of the items in the current cart
		HashMap<Long, Double> counts = new HashMap<>();
		// treat all products in the current cart equally, and sum all the occurrences
		for (Long product : currentItems) {
			addAllCountsOfProduct(counts, product);
		}

		if (counts.isEmpty()) {
			throw new UseFallBackException(
					"No item was bought together with the current cart. Therefore, all counts are 0.");
		}

		// the count list contains all items in the current cart
		// however, this is fine, as it is filtered
		return filterRecommendations(counts, currentItems);
	}

	/**
	 * Adds the counts of the given product to the given count list.
	 * 
	 * @param counts
	 *            The count list, assinging each product id, how often it was bought
	 *            with the given product.
	 * @param product
	 *            The product id of the specific product.
	 */
	private void addAllCountsOfProduct(HashMap<Long, Double> counts, Long product) {
		for (Set<OrderItemSet> set : getUserItemSets().values()) {
			// ignore which user bought which set
			for (OrderItemSet orderset : set) {
				// look through all orders bought
				if (orderset.getOrderset().keySet().contains(product)) {
					for (Long o : orderset.getOrderset().keySet()) {
						// we count all order of the set (including the product we are currently looking
						// at)
						if (counts.containsKey(o)) {
							// we do not count the NUMBER of items, just if the item occurred in the order
							counts.put(o, counts.get(o) + 1);
						} else {
							counts.put(o, 1.0);
						}
					}
				}
			}
		}
	}
}

### END FILE ###

### FILE: algorithm\impl\pop\PopularityBasedRecommender.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.algorithm.impl.pop;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import tools.descartes.teastore.recommender.algorithm.AbstractRecommender;

/**
 * A simple Recommender that makes recommendations based on general popularity.
 * 
 * @author Johannes Grohmann
 *
 */
public class PopularityBasedRecommender extends AbstractRecommender {

	/**
	 * Map with all product IDs and their corresponding total purchase counts.
	 */
	private HashMap<Long, Double> counts;

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * tools.descartes.teastore.recommender.algorithm.AbstractRecommender#
	 * execute( java.util.List)
	 */
	@Override
	protected List<Long> execute(Long userid, List<Long> currentItems) {
		return filterRecommendations(counts, currentItems);
	}

	@Override
	protected void executePreprocessing() {
		// assigns each product a quantity
		counts = new HashMap<>();
		// calculate product frequencies
		for (Map<Long, Double> usermap : getUserBuyingMatrix().values()) {
			for (Entry<Long, Double> product : usermap.entrySet()) {
				if (!counts.containsKey(product.getKey())) {
					counts.put(product.getKey(), product.getValue());
				} else {
					counts.put(product.getKey(), counts.get(product.getKey()) + product.getValue());
				}
			}
		}

	}
}

### END FILE ###

### FILE: rest\RecommendEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import java.util.List;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.RecommenderSelector;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Recommender REST endpoint.
 * 
 * @author Johannes Grohmann
 *
 */
@Path("recommend")
@Produces({ "application/json" })
@Consumes({ "application/json" })
public class RecommendEndpoint {

	/**
	 * Return a list of all {@link Product}s, that are recommended for the given
	 * {@link User} buying the given list of {@link OrderItem}s. <br>
	 * 
	 * The returning list does not contain any {@link Product} that is already part
	 * of the given list of {@link OrderItem}s. It might be empty, however.
	 * 
	 * @param currentItems
	 *            A list, containing all {@link OrderItem}s in the current cart.
	 *            Might be empty.
	 * @param uid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of {@link Long} objects, containing all {@link Product} IDs that
	 *         are recommended to add to the cart, or an INTERNALSERVERERROR, if the
	 *         recommendation failed.
	 */
	@POST
	public Response recommend(List<OrderItem> currentItems, @QueryParam("uid") final Long uid) {
		List<Long> recommended = RecommenderSelector.getInstance().recommendProducts(uid, currentItems);
		return Response.ok().entity(recommended).build();
	}
}

### END FILE ###

### FILE: rest\RecommendSingleEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import java.util.LinkedList;
import java.util.List;

import jakarta.ws.rs.Consumes;
import jakarta.ws.rs.POST;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.RecommenderSelector;
import tools.descartes.teastore.entities.OrderItem;
import tools.descartes.teastore.entities.Product;
import tools.descartes.teastore.entities.User;

/**
 * Recommender REST endpoint for single recommendation.
 * 
 * @author Johannes Grohmann
 *
 */
@Path("recommendsingle")
@Produces({ "application/json" })
@Consumes({ "application/json" })
public class RecommendSingleEndpoint {

	/**
	 * Return a list of all {@link Product}s, that are recommended for the given
	 * {@link User} buying the given {@link OrderItem}. <br>
	 * 
	 * The returning list does not contain the {@link Product} of the respective
	 * {@link OrderItem}. It might be empty, however.
	 * 
	 * @param item
	 *            An {@link OrderItem} to use as recommender. Must not be null.
	 * @param uid
	 *            The id of the {@link User} to recommend for. May be null.
	 * @return List of {@link Long} objects, containing all {@link Product} IDs that
	 *         are recommended to add to the cart, or an INTERNALSERVERERROR, if the
	 *         recommendation failed.
	 */
	@POST
	public Response recommend(OrderItem item, @QueryParam("uid") final Long uid) {
		if (item == null) {
			throw new NullPointerException("OrderItem must not be null.");
		}
		LinkedList<OrderItem> list = new LinkedList<OrderItem>();
		list.add(item);
		List<Long> recommended = RecommenderSelector.getInstance().recommendProducts(uid, list);
		return Response.ok().entity(recommended).build();
	}
}

### END FILE ###

### FILE: rest\TrainEndpoint.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.rest;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.Response;

import tools.descartes.teastore.recommender.algorithm.IRecommender;
import tools.descartes.teastore.recommender.servlet.TrainingSynchronizer;
import tools.descartes.teastore.entities.Order;
import tools.descartes.teastore.entities.OrderItem;

/**
 * REST endpoint to trigger the (re)training of the Recommender.
 *
 * @author Johannes Grohmann
 *
 */
@Path("train")
@Produces({ "text/plain", "application/json" })
public class TrainEndpoint {

	/**
	 * Triggers the training of the recommendation algorithm. It retrieves all data
	 * {@link OrderItem}s and all {@link Order}s from the database entity and is
	 * therefore both very network and computation time intensive. <br>
	 * This method must be called before the {@link RecommendEndpoint} is usable, as
	 * the {@link IRecommender} will throw an
	 * {@link UnsupportedOperationException}.<br>
	 * Calling this method a second time initiates a new training process from scratch.
	 *
	 * @return Returns a {@link Response} with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_OK} or with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_INTERNAL_SERVER_ERROR},
	 *         if the operation failed.
	 */
	@GET
	public Response train() {
		try {
			long start = System.currentTimeMillis();
			long number = TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
			long time = System.currentTimeMillis() - start;
			if (number != -1) {
				return Response.ok("The (re)train was succesfully done. It took " + time + "ms and " + number
						+ " of Orderitems were retrieved from the database.").build();
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		// set ready to true anyway to avoid being stuck
		return Response.status(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())
				.entity("The (re)trainprocess failed.").build();
	}

	/**
	 * Returns the last time stamp, which was considered at the training of this
	 * instance.
	 *
	 * @return Returns a {@link Response} with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_OK} containing the
	 *         maximum considered time as String or with
	 *         {@link jakarta.servlet.http.HttpServletResponse#SC_INTERNAL_SERVER_ERROR},
	 *         if the operation failed.
	 */
	@GET
	@Path("timestamp")
	public Response getTimeStamp() {
		if (TrainingSynchronizer.getInstance().getMaxTime() == TrainingSynchronizer.DEFAULT_MAX_TIME_VALUE) {
			return Response.status(Response.Status.PRECONDITION_FAILED.getStatusCode())
					.entity("The collection of the current maxTime was not possible.").build();
		}
		return Response.ok(TrainingSynchronizer.getInstance().getMaxTime()).build();
	}

	/**
	 * This methods checks, if the service is ready to serve recommendation
	 * requests, i.e., if the algorithm has finished training and no retraining process
	 * is running. However, this does not imply that issuing a recommendation will
	 * fail, if this method returns false. For example, if a retraining is issued,
	 * the old trained instance might still answer issued requests until the new
	 * instance is fully trained. However, performance behavior is probably
	 * influenced.
	 *
	 * @return True, if recommender is ready; false, if not.
	 */
	@GET
	@Path("isready")
	public Response isReady() {
		if (TrainingSynchronizer.getInstance().isReady()) {
			return Response.ok(true).build();
		} else {
			return Response.serverError().entity(false).build();
		}
	}
}

### END FILE ###

### FILE: servlet\IndexServlet.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Index Servlet for the Recommender Component. Provides some basic debug
 * information for deployers and testers.
 * 
 * @author Johannes Grohmann
 */
@WebServlet("/index")
public class IndexServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public IndexServlet() {
		super();
	}

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse
	 *      response)
	 * @param request
	 *            The request.
	 * @param response
	 *            The response.
	 * @throws ServletException
	 *             In case of servlet Exception.
	 * @throws IOException
	 *             In case of IOException.
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		response.getWriter().println("This is the recommender module running at " + request.getProtocol() + "://"
				+ request.getLocalAddr() + ":" + request.getLocalPort() + "/" + request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
	 *      response)
	 * @param request
	 *            The request.
	 * @param response
	 *            The response.
	 * @throws ServletException
	 *             In case of servlet Exception.
	 * @throws IOException
	 *             In case of IOException.
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}

}

### END FILE ###

### FILE: servlet\RecommenderStartup.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import javax.naming.InitialContext;
import javax.naming.NamingException;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.opentracing.util.GlobalTracer;
import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.loadbalancers.ServiceLoadBalancer;
import tools.descartes.teastore.registryclient.tracing.Tracing;
import tools.descartes.teastore.registryclient.util.RESTClient;

/**
 * Startup Handler for the Recommender Service.
 *
 * @author Simon Eismann, Johannes Grohmann
 *
 */
@WebListener
public class RecommenderStartup implements ServletContextListener {

	private static final int REST_READ_TIMOUT = 1750;

	private static final Logger LOG = LoggerFactory.getLogger(RecommenderStartup.class);

	/**
	 * Also set this accordingly in RegistryClientStartup.
	 */

	/**
	 * Empty constructor.
	 */
	public RecommenderStartup() {

	}

	/**
	 * @see ServletContextListener#contextDestroyed(ServletContextEvent)
	 * @param event
	 *            The servlet context event at destruction.
	 */
	public void contextDestroyed(ServletContextEvent event) {
		RegistryClient.getClient().unregister(event.getServletContext().getContextPath());
	}

	/**
	 * @see ServletContextListener#contextInitialized(ServletContextEvent)
	 * @param event
	 *            The servlet context event at initialization.
	 */
	public void contextInitialized(ServletContextEvent event) {
		GlobalTracer.register(Tracing.init(Service.RECOMMENDER.getServiceName()));
		RESTClient.setGlobalReadTimeout(REST_READ_TIMOUT);
		ServiceLoadBalancer.preInitializeServiceLoadBalancers(Service.PERSISTENCE);
		RegistryClient.getClient().runAfterServiceIsAvailable(Service.PERSISTENCE, () -> {
			TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
			RegistryClient.getClient().register(event.getServletContext().getContextPath());
		}, Service.RECOMMENDER);
		try {
			long looptime = (Long) new InitialContext().lookup("java:comp/env/recommenderLoopTime");
			// if a looptime is specified, a retraining daemon is started
			if (looptime > 0) {
				new RetrainDaemon(looptime).start();
				LOG.info("Periodic retraining every " + looptime + " milliseconds");
			} else {
				LOG.info("Recommender loop time not set. Disabling periodic retraining.");
			}
		} catch (NamingException e) {
			LOG.info("Recommender loop time not set. Disabling periodic retraining.");
		}

	}

}

### END FILE ###

### FILE: servlet\RetrainDaemon.java ###
/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package tools.descartes.teastore.recommender.servlet;

import tools.descartes.teastore.registryclient.RegistryClient;
import tools.descartes.teastore.registryclient.Service;
import tools.descartes.teastore.registryclient.StartupCallback;

/**
 * DaemonThread for periodic retraining if required.
 * 
 * @author Johannes Grohmann
 */
public class RetrainDaemon extends Thread {

	/**
	 * The time between retraining in milliseconds.
	 */
	private long looptime;

	/**
	 * Constructor.
	 * 
	 * @param looptime
	 *            The time between retraining in milliseconds
	 */
	public RetrainDaemon(long looptime) {
		super();
		// set as daemon thread
		setDaemon(true);
		this.looptime = looptime;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		super.run();
		// repeat until stopped
		while (true) {
			try {
				Thread.sleep(looptime);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			// wait for the persistance service and then retrain
			RegistryClient.getClient().runAfterServiceIsAvailable(Service.PERSISTENCE, new StartupCallback() {
				@Override
				public void callback() {
					TrainingSynchronizer.getInstance().retrieveDataAndRetrain();
				}
			}, Service.RECOMMENDER);
		}

	}

}

### END FILE ###

