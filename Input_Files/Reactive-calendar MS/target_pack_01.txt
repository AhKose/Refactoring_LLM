### MANIFESTO - REACTIVE CALENDAR TARGET REFACTORING ###
- Role: Senior Architect
- Target Module: reactive-calendar-api
- Architecture: Architecture: Spring WebFlux
- Guardrails: 
  1. Reactive Integrity: Maintain non-blocking Mono/Flux flows. Do NOT introduce blocking calls.
  2. Observability: Ensure Micrometer metrics and Jaeger traces are preserved.
  3. API Stability: Do NOT change existing REST endpoints (@GetMapping).
- Principles: 
  - Extract complex mapping logic into private methods.
  - Optimize DB queries with @Transactional(readOnly = true).
  - Use Immutable DTOs for data return.
- Output: Return only changed files in ### FILE: <path> ... ### END FILE format.

### FILE: CalendarApplication.java ###
package com.microservices.calendar.api;

import com.microservices.calendar.api.adapter.MultiMapExtractAdapter;
import com.microservices.calendar.api.adapter.ReactiveMultiMapExtractAdapter;
import com.microservices.calendar.api.configuration.InitConfiguration;
import io.opentracing.Scope;
import io.opentracing.SpanContext;
import io.opentracing.propagation.Format;
import io.opentracing.tag.Tags;
import io.reactivex.Single;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.Launcher;
import io.vertx.core.json.JsonObject;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import io.vertx.reactivex.config.ConfigRetriever;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;
import io.vertx.reactivex.core.http.HttpServerResponse;
import io.vertx.reactivex.ext.web.Router;
import io.vertx.reactivex.ext.web.handler.BodyHandler;
import io.vertx.reactivex.ext.web.handler.CorsHandler;
import io.vertx.reactivex.ext.web.handler.StaticHandler;
import io.vertx.reactivex.ext.web.RoutingContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.uber.jaeger.Configuration;
import com.uber.jaeger.micrometer.MicrometerMetricsFactory;
import com.uber.jaeger.samplers.ConstSampler;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.prometheus.PrometheusConfig;
import io.micrometer.prometheus.PrometheusMeterRegistry;
import io.opentracing.Span;
import io.opentracing.Tracer;
import static com.microservices.calendar.api.controller.Errors.error;
import static io.vertx.core.http.HttpHeaders.CONTENT_TYPE;
import static io.vertx.core.http.HttpMethod.*;

public class CalendarApplication extends AbstractVerticle {
    private static Logger logger = LoggerFactory.getLogger(CalendarApplication.class);

    private final String API_KEY = "Reactive-Calendar-API-User-Key";

    public Tracer appTracer;
    public SpanContext parentSpanContext;

    public static void main(final String[] args) {
        Launcher.executeCommand("run", CalendarApplication.class.getName());
    }

    @Override
    public void start() {
        // Create a router object.
        Router router = Router.router(vertx);

        CorsHandler cors = CorsHandler.create("*");
        cors.allowedHeader(CONTENT_TYPE.toString());
        cors.allowedMethod(POST);
        router.route().handler(cors);

        String jaegerHost = null;
        Integer jaegerPort = null;

        try {
            jaegerHost = System.getenv("JAEGER_HOST");
            jaegerPort = Integer.valueOf(System.getenv("JAEGER_PORT"));
        }catch (Exception e) {
            jaegerHost = "localhost";
            jaegerPort = 6831;
        }

        MicrometerMetricsFactory metricsFactory = new MicrometerMetricsFactory();

        Configuration configuration = new Configuration("jaeger-vertx-calendar");
        appTracer = configuration
            .withReporter(
                new Configuration.ReporterConfiguration()
                    .withLogSpans(true)
                    .withFlushInterval(1000)
                    .withMaxQueueSize(10000)
                    .withSender(
                        new Configuration.SenderConfiguration()
                            .withAgentHost(jaegerHost)
                            .withAgentPort(jaegerPort)
                    )
            )
            .withSampler(
                new Configuration.SamplerConfiguration()
                    .withType(ConstSampler.TYPE)
                    .withParam(1)
            )
            .getTracerBuilder()
            .withMetricsFactory(metricsFactory)
            .build();

        // Bind "/" to our hello message - so we are still compatible.
        router.route("/").handler(routingContext -> {
            HttpServerResponse response = routingContext.response();
            response
                .putHeader("content-type", "text/html")
                .end("<h1>Reactive Calendar API Vert.x 3.6.3.redhat-00009 application</h1>");
        });

        PrometheusMeterRegistry registry = new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
        Metrics.addRegistry(registry);

        startPrometheusHttpServer(registry);

        // enable parsing of request bodies
        router.route().handler(BodyHandler.create());
        // implement REST CRUD mapping
        router.post("/api/v1/event").handler(this::createEvent);
        // health check
        router.get("/health").handler(rc -> rc.response().end("OK"));
        // web interface
        router.get().handler(StaticHandler.create());

        ConfigStoreOptions store = new ConfigStoreOptions()
            .setType("file")
            .setFormat("yaml")
            .setConfig(new JsonObject().put("path", "conf/config.yaml")
            );

        ConfigRetriever retriever = ConfigRetriever.create(vertx,
            new ConfigRetrieverOptions().addStore(store));

        InitConfiguration.init(vertx)
            .andThen(startHttpServer(router))
            .subscribe(
                (http) -> System.out.println("Server ready on port " + http.actualPort()),
                Throwable::printStackTrace
            );
    }

    private void startPrometheusHttpServer(PrometheusMeterRegistry registry) {
        System.out.println("VertX Prometheus listening on port: 8081");

        vertx.createHttpServer()
            .requestHandler(req -> req.response().end(registry.scrape()))
            .listen(8081);
    }

    private Single<HttpServer> startHttpServer(Router router) {
        Integer vertxPort = null;

        try {
            vertxPort = Integer.valueOf(System.getenv("HTTP_PORT"));
        }catch (Exception e) {
            vertxPort = 8070;
        }

        System.out.println("VertX app listening on port:"+vertxPort);

        // Create the HTTP server and pass the "accept" method to the request handler.
        return vertx
            .createHttpServer()
            .requestHandler(router)
            .rxListen(vertxPort);
    }

    private void createEvent(RoutingContext ctx) {
        parentSpanContext = appTracer.extract(Format.Builtin.HTTP_HEADERS,
                new ReactiveMultiMapExtractAdapter(ctx.request().headers()));

        System.out.println("\n\n\n");
        System.out.println("REQUEST HEADERS");
        ctx.request().headers().entries().forEach((e) -> {
            Map.Entry entry = e;
            System.out.println(e.getKey() + ":" + e);
        });

        try (Scope scope = appTracer
                .buildSpan(ctx.request().method().toString())
                .asChildOf(parentSpanContext)
                .startActive(true)) {

            logger.info("VertX - checking request header");
            String userApiKey = ctx.request().getHeader(API_KEY);

            if (userApiKey == null) {
                logger.info("invalid header: " + API_KEY + " not found");
                error(ctx, 400, "invalid header: " + API_KEY + " not found");
                return;
            }

            logger.info("VertX - checking request body");
            JsonObject item;

            try {
                item = ctx.getBodyAsJson();
            } catch (RuntimeException e) {
                logger.info("invalid payload: expecting json");
                error(ctx, 415, "invalid payload: expecting json");
                return;
            }

            if (item == null) {
                logger.info("invalid payload: expecting json");
                error(ctx, 415, "invalid payload: expecting json");
                return;
            }

            logger.info("VertX - post new event");
            logger.info("start: " + item.getValue("startDate"));
            logger.info("end: " + item.getValue("endDate"));
            logger.info("calories: " + item.getInteger("calories"));

            item.put("synced", true);

            ctx.response()
                    .putHeader("Location", "/api/v1/event/" + item.getLong("id"))
                    .putHeader("Content-Type", "application/json")
                    .setStatusCode(201)
                    .end(item.encodePrettily());

            System.out.println("received new reactive-calendar event from user api-key=" + userApiKey);
        }
    }

    private void writeError(RoutingContext ctx, Throwable err) {
        if (err instanceof NoSuchElementException) {
            error(ctx, 404, err);
        } else if (err instanceof IllegalArgumentException) {
            error(ctx, 422, err);
        } else {
            error(ctx, 409, err);
        }
    }

    private String getEnv(String key, String defaultValue) {
        String s = System.getenv(key);
        if (s == null) {
            return defaultValue;
        }
        return s;
    }
}

### END FILE ###

### FILE: adapter\MultiMapExtractAdapter.java ###
package com.microservices.calendar.api.adapter;

import io.opentracing.propagation.TextMap;
import io.vertx.core.MultiMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author Pavol Loffay
 */
public class MultiMapExtractAdapter implements TextMap {

    private MultiMap headers;

    public MultiMapExtractAdapter(MultiMap headers) {
        this.headers = headers;
    }

    @Override
    public Iterator<Map.Entry<String, String>> iterator() {
        return headers.entries().iterator();
    }

    @Override
    public void put(String key, String value) {
        throw new UnsupportedOperationException();
    }
}

### END FILE ###

### FILE: adapter\ReactiveMultiMapExtractAdapter.java ###
package com.microservices.calendar.api.adapter;

import io.opentracing.propagation.TextMap;
import io.vertx.reactivex.core.MultiMap;
import java.util.Iterator;
import java.util.Map;

/**
 * @author Raphael Abreu
 */
public class ReactiveMultiMapExtractAdapter implements TextMap {

    private MultiMap headers;

    public ReactiveMultiMapExtractAdapter(MultiMap headers) {
        this.headers = headers;
    }

    @Override
    public Iterator<Map.Entry<String, String>> iterator() {
        return headers.entries().iterator();
    }

    @Override
    public void put(String key, String value) {
        throw new UnsupportedOperationException();
    }
}

### END FILE ###

### FILE: configuration\InitConfiguration.java ###
package com.microservices.calendar.api.configuration;

import io.reactivex.Completable;
import io.vertx.reactivex.core.Vertx;

public class InitConfiguration {

    private InitConfiguration() { }

    public static Completable init(Vertx vertx) {
        return Completable.complete();
    }
}

### END FILE ###

### FILE: controller\Errors.java ###
package com.microservices.calendar.api.controller;

import io.vertx.core.json.JsonObject;
import io.vertx.reactivex.ext.web.RoutingContext;

public class Errors {

    public static void error(RoutingContext ctx, int status, String cause) {
        JsonObject error = new JsonObject()
            .put("error", cause)
            .put("code", status)
            .put("path", ctx.request().path());
        ctx.response()
            .putHeader("Content-Type", "application/json")
            .setStatusCode(status)
            .end(error.encodePrettily());
    }

    public static void error(RoutingContext ctx, int status, Throwable cause) {
        error(ctx, status, cause.getMessage());
    }


}

### END FILE ###

### FILE: handler\TracingHandler.java ###
package com.microservices.calendar.api.handler;

import io.opentracing.contrib.vertx.ext.web.MultiMapExtractAdapter;
import io.opentracing.contrib.vertx.ext.web.WebSpanDecorator;
import io.opentracing.contrib.vertx.ext.web.WebSpanDecorator.StandardTags;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import io.opentracing.Span;
import io.opentracing.SpanContext;
import io.opentracing.Tracer;
import io.opentracing.propagation.Format;
import io.opentracing.tag.Tags;
import io.vertx.core.Handler;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import io.vertx.ext.web.RoutingContext;

/**
 * Handler which creates tracing data for all server requests. It should be added to
 * {@link io.vertx.ext.web.Route#handler(Handler)} and {@link io.vertx.ext.web.Route#failureHandler(Handler)} as the
 * first in the chain.
 *
 * @author Pavol Loffay
 */
public class    TracingHandler implements Handler<RoutingContext> {
    private static final Logger log = LoggerFactory.getLogger(TracingHandler.class);
    public static final String CURRENT_SPAN = TracingHandler.class.getName() + ".severSpan";

    private final Tracer tracer;
    private final List<WebSpanDecorator> decorators;

    public TracingHandler(Tracer tracer) {
        this(tracer, Collections.singletonList(new StandardTags()));
    }

    public TracingHandler(Tracer tracer, List<WebSpanDecorator> decorators) {
        this.tracer = tracer;
        this.decorators = new ArrayList<>(decorators);
    }

    @Override
    public void handle(RoutingContext routingContext) {
        if (routingContext.failed()) {
            handlerFailure(routingContext);
        } else {
            handlerNormal(routingContext);
        }
    }

    protected void handlerNormal(RoutingContext routingContext) {
        // reroute
        Object object = routingContext.get(CURRENT_SPAN);

        if (object instanceof Span) {
            Span span = (Span) object;
            decorators.forEach(spanDecorator ->
                    spanDecorator.onReroute(routingContext.request(), span));

            // TODO in 3.3.3 it was sufficient to add this when creating the span
            routingContext.addBodyEndHandler(finishEndHandler(routingContext, span));
            routingContext.next();
            return;
        }

        SpanContext extractedContext = tracer.extract(Format.Builtin.HTTP_HEADERS,
            new MultiMapExtractAdapter(routingContext.request().headers()));

        Span span = tracer.buildSpan(routingContext.request().method().toString())
            .asChildOf(extractedContext)
            .ignoreActiveSpan() // important since we are on event loop
            .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)
            .startManual();

        decorators.forEach(spanDecorator ->
            spanDecorator.onRequest(routingContext.request(), span));

        routingContext.put(CURRENT_SPAN, span);

        // TODO it's not guaranteed that body end handler is always called
        // https://github.com/vert-x3/vertx-web/issues/662

        routingContext.addBodyEndHandler(finishEndHandler(routingContext, span));
        routingContext.next();
    }

    protected void handlerFailure(RoutingContext routingContext) {
        Object object = routingContext.get(CURRENT_SPAN);
        if (object instanceof Span) {
            final Span span = (Span)object;
            routingContext.addBodyEndHandler(event -> decorators.forEach(spanDecorator ->
                    spanDecorator.onFailure(routingContext.failure(), routingContext.response(), span)));
        }

        routingContext.next();
    }

    private Handler<Void> finishEndHandler(RoutingContext routingContext, Span span) {
        return handler -> {
            decorators.forEach(spanDecorator ->
                    spanDecorator.onResponse(routingContext.request(), span));
            span.finish();
        };
    }

    /**
     * Helper method for accessing server span context associated with current request.
     *
     * @param routingContext routing context
     * @return server span context or null if not present
     */
    public static SpanContext serverSpanContext(RoutingContext routingContext) {
        SpanContext serverContext = null;

        Object object = routingContext.get(CURRENT_SPAN);
        if (object instanceof Span) {
            Span span = (Span) object;
            serverContext = span.context();
        } else {
            log.error("Sever SpanContext is null or not an instance of SpanContext");
        }

        return serverContext;
    }
}

### END FILE ###

### FILE: handler\WebSpanDecorator.java ###
package com.microservices.calendar.api.handler;

import io.vertx.core.Handler;
import java.util.HashMap;
import java.util.Map;
import io.opentracing.Span;
import io.opentracing.tag.Tags;
import io.vertx.core.http.HttpServerRequest;
import io.vertx.core.http.HttpServerResponse;

/**
 * Decorate server span at different stages. Do not call blocking code inside decorators!
 *
 * @author Pavol Loffay
 */
public interface WebSpanDecorator {
    /**
     * Decorate span when span is started.
     *
     * @param request server request
     * @param span server span
     */
    void onRequest(HttpServerRequest request, Span span);

    /**
     * Decorate span when span is rerouted.
     *
     * @param request server request
     * @param span server span
     */
    void onReroute(HttpServerRequest request, Span span);

    /**
     * Decorate span when the response is known. This is effectively invoked in BodyEndHandler which is added to
     * - {@link io.vertx.ext.web.RoutingContext#addBodyEndHandler(Handler)}
     *
     * @param request server request
     * @param span server span
     */
    void onResponse(HttpServerRequest request, Span span);

    /**
     * Decorate request when an exception is thrown during request processing.
     *
     * @param throwable an exception thrown when processing the request
     * @param response server response
     * @param span server span
     */
    void onFailure(Throwable throwable, HttpServerResponse response, Span span);

    /**
     * Decorator which adds standard set of tags e.g. HTTP/PEER/ERROR tags.
     */
    class StandardTags implements WebSpanDecorator {
        @Override
        public void onRequest(HttpServerRequest request, Span span) {
            Tags.COMPONENT.set(span, "vertx");
            Tags.HTTP_METHOD.set(span, request.method().toString());
            Tags.HTTP_URL.set(span, request.absoluteURI());
        }

        @Override
        public void onReroute(HttpServerRequest request, Span span) {
            Map<String, String> logs = new HashMap<>(2);
            logs.put("event", "reroute");
            logs.put(Tags.HTTP_URL.getKey(), request.absoluteURI());
            logs.put(Tags.HTTP_METHOD.getKey(), request.method().toString());
            span.log(logs);
        }

        @Override
        public void onResponse(HttpServerRequest request, Span span) {
            Tags.HTTP_STATUS.set(span, request.response().getStatusCode());
        }

        @Override
        public void onFailure(Throwable throwable, HttpServerResponse response, Span span) {
            Tags.ERROR.set(span, Boolean.TRUE);

            if (throwable != null) {
                span.log(exceptionLogs(throwable));
            }
        }

        public static Map<String, Object> exceptionLogs(Throwable throwable) {
            Map<String, Object> errorLog = new HashMap<>(2);
            errorLog.put("event", Tags.ERROR.getKey());
            errorLog.put("error.object", throwable);

            return errorLog;
        }
    }
}

### END FILE ###

